# CLAUDE.md

This file provides guidance when working with code in this repository.

> **Note**: This is a personal fork of dorkitude/linctl, renamed to lincli. This fork is maintained by Shane Dolley for personal use and is not intended for upstream contribution or public distribution via Homebrew.

## Project Overview

**lincli** is a comprehensive Go-based CLI tool for Linear's GraphQL API. The tool is designed to be both agent-friendly (via `--json` output) and human-friendly (via interactive table and plaintext formats).

## Common Commands

### Build & Development
```bash
make build          # Build the lincli binary
make deps           # Install/update dependencies (go mod download + tidy)
make fmt            # Format code (go fmt ./...)
make lint           # Run linter (requires golangci-lint)
make test           # Run smoke tests via smoke_test.sh
make test-verbose   # Run smoke tests with verbose output
make install        # Build and install to /usr/local/bin (requires sudo)
make dev-install    # Create development symlink to /usr/local/bin

# Run without building
go run main.go [command] [flags]

# Run after building
./lincli [command] [flags]
```

### Testing
- **Smoke tests**: `./smoke_test.sh` - Tests all read-only commands
- **Manual testing**: Run `lincli auth` to authenticate, then test commands
- Integration tests are read-only and safe with production API keys

## Architecture

### Project Structure

```
lincli/
├── main.go              # Entry point, embeds README.md
├── cmd/                 # Cobra command definitions
│   ├── root.go          # Root command, global flags, config
│   ├── auth.go          # Authentication commands
│   ├── issue.go         # Issue management (list, get, create, update, search)
│   ├── project.go       # Project commands
│   ├── team.go          # Team commands
│   ├── user.go          # User commands
│   ├── comment.go       # Comment commands
│   └── docs.go          # Embedded README rendering
├── pkg/
│   ├── api/
│   │   ├── client.go       # GraphQL client implementing graphql.Client interface
│   │   ├── generated.go    # AUTO-GENERATED by genqlient (do not edit)
│   │   ├── adapter.go      # Adapter layer for backward compatibility
│   │   ├── types.go        # Legacy type definitions for backward compatibility
│   │   ├── genqlient.yaml  # genqlient configuration
│   │   ├── schema.graphql  # Linear's GraphQL schema
│   │   └── operations/     # GraphQL operation definitions
│   │       ├── issues.graphql
│   │       ├── projects.graphql
│   │       ├── teams.graphql
│   │       ├── users.graphql
│   │       └── comments.graphql
│   ├── auth/
│   │   └── auth.go      # Auth config management (~/.lincli-auth.json)
│   ├── output/
│   │   └── output.go    # Output formatting (table, plaintext, JSON)
│   └── utils/
│       └── time.go      # Time expression parser (e.g., "3_weeks_ago")
└── Formula/             # Homebrew formula
```

### Key Design Patterns

#### Command Structure
All commands follow this pattern:
1. Parse flags using Cobra
2. Get auth header via `auth.GetAuthHeader()`
3. Create API client: `client := api.NewClient(authHeader)`
4. Build filter/query parameters from flags
5. Call API method with `context.Background()`
6. Render output using `output` package functions

#### API Client
- **Location**: `pkg/api/client.go`
- **Pattern**: Implements `graphql.Client` interface for genqlient integration
- **Core methods**:
  - `MakeRequest()`: Required by genqlient for generated code
  - `Execute()`: Legacy method for backward compatibility (deprecated)
- **Usage**: Read commands call genqlient-generated functions directly (e.g., `api.ListIssues()`)
- **Adapter layer**: `pkg/api/adapter.go` provides deprecated adapters for backward compatibility with write operations
  - Read operation adapters (GetIssues, GetTeams, etc.) are deprecated - use generated functions directly
  - Write operation adapters (CreateIssue, UpdateIssue, etc.) still in use until Phase 2 migration
- **Code generation**: Operations defined in `pkg/api/operations/*.graphql` are compiled to type-safe Go code via genqlient

#### Authentication
- **Storage**: `~/.lincli-auth.json` (0600 permissions)
- **Format**: JSON with `api_key` field
- **Flow**: Personal API Key only (no OAuth)
- **Validation**: Tests API key by fetching viewer on login

#### Output Formatting
Three output modes controlled by global flags:
- **Table** (default): Interactive, colored tablewriter output
- **Plaintext** (`--plaintext`, `-p`): Markdown-style for non-interactive use
- **JSON** (`--json`, `-j`): Machine-readable, for agents and scripts

The `output` package provides:
- `output.JSON()` - Marshal and print JSON
- `output.Error()` - Format errors per output mode
- `output.Success()` - Format success messages
- `output.Info()` - Format info messages
- `output.Table()` - Render table output

#### Time Filtering
The `utils.ParseTimeExpression()` function converts human-readable time expressions:
- Relative: `3_weeks_ago`, `6_months_ago`, `1_year_ago`
- Special: `all_time` (no filter)
- ISO dates: `2025-07-01` or `2025-07-01T15:30:00Z`
- Default: `6_months_ago` (when no flag provided)

**Important**: List commands default to 6-month filter for performance. Use `--newer-than all_time` to see all items.

### GraphQL Code Generation with genqlient

This project uses [genqlient](https://github.com/Khan/genqlient) to generate type-safe GraphQL code from operation definitions.

#### Architecture
- **Operation definitions**: Located in `pkg/api/operations/*.graphql`
- **Generated code**: `pkg/api/generated.go` (auto-generated, do not edit manually)
- **Adapter layer**: `pkg/api/adapter.go` provides backward-compatible wrappers
- **Legacy types**: `pkg/api/types.go` contains type definitions for backward compatibility

#### How It Works
1. Define GraphQL operations in `.graphql` files:
   ```graphql
   # pkg/api/operations/issues.graphql
   query GetIssues($filter: IssueFilter, $first: Int, $after: String, $orderBy: PaginationOrderBy) {
       issues(filter: $filter, first: $first, after: $after, orderBy: $orderBy) {
           nodes {
               id
               identifier
               title
               # ... more fields
           }
           pageInfo { hasNextPage endCursor }
       }
   }
   ```

2. Run code generation:
   ```bash
   go generate ./pkg/api
   ```

3. genqlient generates type-safe functions:
   ```go
   // Auto-generated in pkg/api/generated.go
   func GetIssues(ctx context.Context, client graphql.Client, filter IssueFilter, ...) (*GetIssuesResponse, error)
   ```

4. Adapter layer wraps generated code for backward compatibility:
   ```go
   // pkg/api/adapter.go
   func (c *Client) GetIssues(ctx context.Context, filter map[string]interface{}, limit int, ...) (*Issues, error) {
       response, err := GetIssues(ctx, c, filter, limit, ...)
       // Convert generated types to legacy types
       return convertIssuesResponse(response), err
   }
   ```

#### Benefits
- **Type safety**: Compile-time validation of GraphQL queries
- **Auto-completion**: IDE support for generated types
- **Reduced boilerplate**: No manual JSON marshaling/unmarshaling
- **Schema validation**: Catches breaking API changes at build time
- **Performance**: Generated code is optimized and eliminates reflection

### Migration to genqlient

**Status:** ✅ Phase 2 Complete - Write Operations (100%)

The project has fully migrated to using genqlient-generated types directly for both read and write operations:

**Phase 0: Code Generation (Completed)**
- **Tool**: genqlient v0.8.1
- **Entities migrated**: Issues, Projects, Teams, Users, Comments (5 total)
- **Helper methods migrated**: GetTeamMembers (to genqlient), GetTeamStates (eliminated via optimization)
- **Code removed**: 1,604 lines of hand-written code (queries.go: 1,515 + legacy.go: 89)
- **Net reduction**: 1,050 lines (31% reduction in pkg/api)

**Phase 1: Direct Types - Read Operations (Completed)**
- **Read commands migrated**: All 11 read operations (list, get, search) across all entities
- **Filter building**: Migrated from `map[string]interface{}` to typed filters (IssueFilter, ProjectFilter)
- **Response handling**: Direct use of generated types with fragment-based field access
- **Code removed**: 61 lines (buildIssueFilter + deprecation comments added)
- **Adapter functions**: 10 read operations marked deprecated
- **All smoke tests passing**: 39/39
- **Type safety**: Full compile-time validation for all read operations

**Phase 2: Write Operations (Completed)**
- **Write commands migrated**: 4 write operations (issue assign, comment create, issue create, issue update)
- **Input building**: Builder functions for complex commands (5+ fields), inline for simple
- **Type safety**: Replace `map[string]interface{}` with typed input structs (IssueUpdateInput, IssueCreateInput, CommentCreateInput)
- **State lookup optimization**: Eliminated extra GetTeamStates API call by using embedded workflow states (50% API call reduction for state updates)
- **Adapter functions**: 3 write operations marked deprecated (CreateIssue, UpdateIssue, CreateComment)
- **All manual tests passed**: 27 test cases across 4 commands
- **Zero regressions**: All existing functionality preserved

**Commands using direct types:**
- Read operations: `issue list`, `issue get`, `issue search`, `project list`, `project get`, `team list`, `team get`, `team members`, `user list`, `user whoami`, `comment list`
- Write operations: `issue assign`, `issue create`, `issue update`, `comment create`

**Performance optimizations:**
- Team workflow states are embedded in issue fetches, eliminating extra API calls during state validation
- State updates now use embedded states (1 API call instead of 2 - 50% reduction)
- Eliminated adapter conversion overhead for all read and write operations

**Next phase:**
- **Phase 3**: Remove adapter layer entirely (~1,700 lines including conversion functions)

The migration achieves full type safety for all operations, eliminates maintenance burden, catches API changes at compile time, and improves performance through optimized API usage.

### Configuration

- **Config file**: `~/.lincli.yaml` (optional)
- **Auth file**: `~/.lincli-auth.json` (required for authenticated commands)
- **Viper**: Used for config management
- **Environment**: `LINEAR_API_KEY` env var NOT used (only file-based auth)

## Adding New Commands

### Using Direct genqlient Types (Recommended for Read Operations)
For new read commands (list, get, search):

1. **Define GraphQL operation** in appropriate `pkg/api/operations/<entity>.graphql` file:
   ```graphql
   query ListMyData($filter: MyDataFilter, $first: Int, $after: String, $orderBy: PaginationOrderBy) {
       myData(filter: $filter, first: $first, after: $after, orderBy: $orderBy) {
           nodes {
               id
               name
               # ... fields you need
           }
           pageInfo { hasNextPage endCursor }
       }
   }
   ```

2. **Generate code**:
   ```bash
   go generate ./pkg/api
   ```
   This creates type-safe functions in `pkg/api/generated.go` (e.g., `ListMyData()`)

3. **Create typed filter builder** in command file (if filters needed):
   ```go
   func buildMyDataFilterTyped(cmd *cobra.Command) api.MyDataFilter {
       filter := api.MyDataFilter{}
       if name, _ := cmd.Flags().GetString("name"); name != "" {
           filter.Name = stringEq(name)  // Use helper functions
       }
       return filter
   }
   ```

4. **Implement command handler** in appropriate `cmd/*.go` file:
   ```go
   - Parse flags
   - Get auth header via `auth.GetAuthHeader()`
   - Create client: `client := api.NewClient(authHeader)`
   - Build typed filter: `filter := buildMyDataFilterTyped(cmd)`
   - Convert pagination params to pointers
   - Call generated function: `resp, err := api.ListMyData(ctx, client, filter, &limit, nil, orderByEnum)`
   - Access response: `resp.MyData.Nodes`
   - Render output using fragment fields (e.g., `node.MyDataListFields.Name`)
   ```

5. **Register command** in `init()` function

6. **Update README.md** with command documentation

7. **Add to smoke_test.sh** if read-only

**Key patterns:**
- Use typed filter structs (`api.MyDataFilter`) instead of `map[string]interface{}`
- Call generated functions directly (`api.ListMyData()`) - no adapters
- Access fields through fragments (`node.MyDataListFields`)
- Add nil checks for nullable fields
- Use helper functions for common patterns (stringEq, boolEq, etc.)

### Using Direct genqlient Types for Write Operations (Recommended)
For new write commands (create, update, delete):

1. **Define GraphQL mutation** in appropriate `pkg/api/operations/<entity>.graphql` file:
   ```graphql
   mutation CreateMyData($input: MyDataCreateInput!) {
       myDataCreate(input: $input) {
           myData {
               ...MyDataFields
           }
       }
   }
   ```

2. **Generate code**:
   ```bash
   go generate ./pkg/api
   ```

3. **Create input builder** (for complex commands with 5+ fields):
   ```go
   func buildMyDataCreateInput(cmd *cobra.Command) api.MyDataCreateInput {
       input := api.MyDataCreateInput{
           RequiredField: value,  // Non-pointer required fields
       }

       // Use Changed() for optional fields to distinguish "not set" from "set to empty"
       if cmd.Flags().Changed("optional-field") {
           val, _ := cmd.Flags().GetString("optional-field")
           input.OptionalField = &val
       }

       return input
   }
   ```

4. **Implement command handler**:
   ```go
   - Parse flags
   - Build typed input using builder function or inline (for simple cases)
   - Call generated mutation: `resp, err := api.CreateMyData(ctx, client, &input)`
   - Unwrap response: `data := resp.MyDataCreate.MyData`
   - Render output using fragment fields
   ```

5. **Test manually** with comprehensive test cases

**Key patterns for write operations:**
- Use `cmd.Flags().Changed()` to detect which optional fields were actually set
- Builder functions for 5+ fields, inline construction for 1-3 fields
- All optional input fields are pointers
- Pass inputs as pointers to mutation functions (`&input`)
- Response unwrapping: `resp.MutationName.Entity`

### Updating Linear's GraphQL Schema
When Linear's API changes, update the schema:

```bash
# Download latest schema
curl -H "Authorization: Bearer $LINEAR_API_KEY" \
     -H "Content-Type: application/json" \
     -d '{"query": "{ __schema { types { name kind description fields { name } } } }"}' \
     https://api.linear.app/graphql | jq > pkg/api/schema.graphql

# Or use the update script if available
./scripts/update-schema.sh

# Regenerate code
go generate ./pkg/api

# Fix any compilation errors from breaking changes
```

## Important Notes

### Issue Filtering
- **Default behavior**: List commands filter to last 6 months (`--newer-than 6_months_ago`)
- **Rationale**: Performance for large workspaces
- **Override**: Use `--newer-than all_time` to see all items
- **Completed items**: Excluded by default, use `--include-completed` flag

### Search vs List
- `issue list`: Uses filters, supports `--assignee`, `--state`, `--team`, `--priority`
- `issue search`: Uses Linear's full-text index, searches title/description/comments
- Both support `--newer-than` and `--include-completed` flags

### Sorting Options
All list commands support `--sort` flag:
- `linear` (default): Linear's manual sort order
- `created`: Sort by creation date (newest first)
- `updated`: Sort by update date (most recently updated first)

### Version Management
- Version is injected at build time via `-ldflags`
- Set in `Makefile` using git tags or commit hash
- Default value is `"dev"` for local development

### Release Process
This is a personal fork. For release process, simply:
1. Create and push git tag (e.g., `v1.2.3`)
2. Build from source using `make build && make install`

### Embedded README
- `main.go` embeds `README.md` using `//go:embed`
- Rendered by `lincli docs` command
- Uses `glamour` for terminal markdown rendering
- Ensures users always have access to docs offline

## Linear API Specifics

### Authentication
- Personal API Keys only (from https://linear.app/settings/api)
- Rate limit: 5,000 requests/hour
- API endpoint: `https://api.linear.app/graphql`

### Common Entities
- **Issue**: `identifier` (e.g., "LIN-123"), includes state, assignee, team, priority
- **Team**: `key` (e.g., "ENG"), not display name
- **Project**: Uses UUID, not human-readable identifier
- **User**: Identified by email for lookups, has `isMe` field for current user
- **State**: Workflow states (e.g., "Todo", "In Progress", "Done")
- **Priority**: 0=None, 1=Urgent, 2=High, 3=Normal, 4=Low

### Parent-Child Relationships
Issues support hierarchy:
- `parent`: Parent issue reference
- `children`: Array of sub-issues
- Displayed recursively in `issue get` command

## Testing Philosophy

- **Smoke tests**: Fast, read-only, safe with production credentials
- **No destructive tests**: All integration tests are read-only
- **Test API key**: Use `.env.test` for integration tests (optional)
- **Manual verification**: Critical operations (create, update) tested manually

## AI Agent Considerations

This tool is designed for both human and AI agent use:

- **Always use `--json` flag** for programmatic access
- **Respect rate limits**: Linear allows 5,000 req/hour
- **Use time filters**: Always specify `--newer-than` to avoid large data loads
- **Issue identifiers**: Use format "TEAM-NUMBER" (e.g., "ENG-123")
- **Team keys**: Use uppercase team key (e.g., "ENG"), not display name
- **Email for users**: Use email addresses for user lookups
- **Error handling**: JSON output includes `{"error": "message"}` format
