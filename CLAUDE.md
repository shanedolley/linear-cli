# CLAUDE.md

This file provides guidance when working with code in this repository.

> **Note**: This is a personal fork of dorkitude/linctl, renamed to lincli. This fork is maintained by Shane Dolley for personal use and is not intended for upstream contribution or public distribution via Homebrew.

## Project Overview

**lincli** is a comprehensive Go-based CLI tool for Linear's GraphQL API. The tool is designed to be both agent-friendly (via `--json` output) and human-friendly (via interactive table and plaintext formats).

## Common Commands

### Build & Development
```bash
make build          # Build the lincli binary
make deps           # Install/update dependencies (go mod download + tidy)
make fmt            # Format code (go fmt ./...)
make lint           # Run linter (requires golangci-lint)
make test           # Run smoke tests via smoke_test.sh
make test-verbose   # Run smoke tests with verbose output
make install        # Build and install to /usr/local/bin (requires sudo)
make dev-install    # Create development symlink to /usr/local/bin

# Run without building
go run main.go [command] [flags]

# Run after building
./lincli [command] [flags]
```

### Testing
- **Smoke tests**: `./smoke_test.sh` - Tests all read-only commands
- **Manual testing**: Run `lincli auth` to authenticate, then test commands
- Integration tests are read-only and safe with production API keys

## Architecture

### Project Structure

```
lincli/
├── main.go              # Entry point, embeds README.md
├── cmd/                 # Cobra command definitions
│   ├── root.go          # Root command, global flags, config
│   ├── auth.go          # Authentication commands
│   ├── issue.go         # Issue management (list, get, create, update, search)
│   ├── project.go       # Project commands
│   ├── team.go          # Team commands
│   ├── user.go          # User commands
│   ├── comment.go       # Comment commands
│   ├── attachment.go    # Attachment management (list, create, upload, update, delete)
│   └── docs.go          # Embedded README rendering
├── pkg/
│   ├── api/
│   │   ├── client.go       # GraphQL client implementing graphql.Client interface
│   │   ├── generated.go    # AUTO-GENERATED by genqlient (do not edit)
│   │   ├── genqlient.yaml  # genqlient configuration
│   │   ├── schema.graphql  # Linear's GraphQL schema
│   │   └── operations/     # GraphQL operation definitions
│   │       ├── issues.graphql
│   │       ├── projects.graphql
│   │       ├── teams.graphql
│   │       ├── users.graphql
│   │       ├── comments.graphql
│   │       └── attachments.graphql
│   ├── auth/
│   │   └── auth.go      # Auth config management (~/.lincli-auth.json)
│   ├── output/
│   │   └── output.go    # Output formatting (table, plaintext, JSON)
│   └── utils/
│       └── time.go      # Time expression parser (e.g., "3_weeks_ago")
└── Formula/             # Homebrew formula
```

### Key Design Patterns

#### Command Structure
All commands follow this pattern:
1. Parse flags using Cobra
2. Get auth header via `auth.GetAuthHeader()`
3. Create API client: `client := api.NewClient(authHeader)`
4. Build filter/query parameters from flags
5. Call API method with `context.Background()`
6. Render output using `output` package functions

#### API Client
- **Location**: `pkg/api/client.go`
- **Pattern**: Implements `graphql.Client` interface for genqlient integration
- **Core method**: `MakeRequest()` - Required by genqlient for generated code
- **Usage**: All commands call genqlient-generated functions directly (e.g., `api.ListIssues()`, `api.CreateIssue()`, `api.GetViewer()`)
- **Code generation**: Operations defined in `pkg/api/operations/*.graphql` are compiled to type-safe Go code via genqlient
- **Type safety**: Full compile-time validation - all GraphQL operations use generated types with fragments for field access

#### Authentication
- **Storage**: `~/.lincli-auth.json` (0600 permissions)
- **Format**: JSON with `api_key` field
- **Flow**: Personal API Key only (no OAuth)
- **Validation**: Tests API key by fetching viewer on login

#### Output Formatting
Three output modes controlled by global flags:
- **Table** (default): Interactive, colored tablewriter output
- **Plaintext** (`--plaintext`, `-p`): Markdown-style for non-interactive use
- **JSON** (`--json`, `-j`): Machine-readable, for agents and scripts

The `output` package provides:
- `output.JSON()` - Marshal and print JSON
- `output.Error()` - Format errors per output mode
- `output.Success()` - Format success messages
- `output.Info()` - Format info messages
- `output.Table()` - Render table output

#### Time Filtering
The `utils.ParseTimeExpression()` function converts human-readable time expressions:
- Relative: `3_weeks_ago`, `6_months_ago`, `1_year_ago`
- Special: `all_time` (no filter)
- ISO dates: `2025-07-01` or `2025-07-01T15:30:00Z`
- Default: `6_months_ago` (when no flag provided)

**Important**: List commands default to 6-month filter for performance. Use `--newer-than all_time` to see all items.

### GraphQL Code Generation with genqlient

This project uses [genqlient](https://github.com/Khan/genqlient) to generate type-safe GraphQL code from operation definitions.

#### Architecture
- **Operation definitions**: Located in `pkg/api/operations/*.graphql`
- **Generated code**: `pkg/api/generated.go` (auto-generated, do not edit manually)
- **Direct usage**: All commands use generated types directly - no adapter layer

#### How It Works
1. Define GraphQL operations in `.graphql` files:
   ```graphql
   # pkg/api/operations/issues.graphql
   query GetIssues($filter: IssueFilter, $first: Int, $after: String, $orderBy: PaginationOrderBy) {
       issues(filter: $filter, first: $first, after: $after, orderBy: $orderBy) {
           nodes {
               id
               identifier
               title
               # ... more fields
           }
           pageInfo { hasNextPage endCursor }
       }
   }
   ```

2. Run code generation:
   ```bash
   go generate ./pkg/api
   ```

3. genqlient generates type-safe functions:
   ```go
   // Auto-generated in pkg/api/generated.go
   func GetIssues(ctx context.Context, client graphql.Client, filter IssueFilter, ...) (*GetIssuesResponse, error)
   ```

4. Commands use generated code directly:
   ```go
   // cmd/issue.go
   client := api.NewClient(authHeader)
   filter := buildIssueFilterTyped(cmd)
   resp, err := api.GetIssues(ctx, client, filter, &limit, nil, orderByEnum)
   // Access response directly
   for _, issue := range resp.Issues.Nodes {
       fmt.Println(issue.IssueListFields.Title)
   }
   ```

#### Benefits
- **Type safety**: Compile-time validation of GraphQL queries
- **Auto-completion**: IDE support for generated types
- **Reduced boilerplate**: No manual JSON marshaling/unmarshaling
- **Schema validation**: Catches breaking API changes at build time
- **Performance**: Generated code is optimized and eliminates reflection

### Migration to genqlient

**Status:** ✅ Phase 3 Complete - Adapter Layer Removed (100%)

The project has completed its migration to genqlient, with all commands using generated types directly and the entire adapter layer removed:

**Phase 0: Code Generation (Completed)**
- **Tool**: genqlient v0.8.1
- **Entities migrated**: Issues, Projects, Teams, Users, Comments (5 total)
- **Helper methods migrated**: GetTeamMembers (to genqlient), GetTeamStates (eliminated via optimization)
- **Code removed**: 1,604 lines of hand-written code (queries.go: 1,515 + legacy.go: 89)
- **Net reduction**: 1,050 lines (31% reduction in pkg/api)

**Phase 1: Direct Types - Read Operations (Completed)**
- **Read commands migrated**: All 11 read operations (list, get, search) across all entities
- **Filter building**: Migrated from `map[string]interface{}` to typed filters (IssueFilter, ProjectFilter)
- **Response handling**: Direct use of generated types with fragment-based field access
- **Code removed**: 61 lines (buildIssueFilter + deprecation comments added)
- **Adapter functions**: 10 read operations marked deprecated
- **All smoke tests passing**: 39/39
- **Type safety**: Full compile-time validation for all read operations

**Phase 2: Write Operations (Completed)**
- **Write commands migrated**: 4 write operations (issue assign, comment create, issue create, issue update)
- **Input building**: Builder functions for complex commands (5+ fields), inline for simple
- **Type safety**: Replace `map[string]interface{}` with typed input structs (IssueUpdateInput, IssueCreateInput, CommentCreateInput)
- **State lookup optimization**: Eliminated extra GetTeamStates API call by using embedded workflow states (50% API call reduction for state updates)
- **Adapter functions**: 3 write operations marked deprecated (CreateIssue, UpdateIssue, CreateComment)
- **All manual tests passed**: 27 test cases across 4 commands
- **Zero regressions**: All existing functionality preserved

**Phase 3: Adapter Layer Removal (Completed)**
- **Remaining migrations**: 2 user lookup operations (issue update assignee, user get command)
- **Auth package migration**: 2 GetViewer calls in pkg/auth/auth.go (Login, GetCurrentUser)
- **Files deleted**: adapter.go (1,674 lines), types.go (429 lines)
- **Dead code removed**: renderIssueCollection function (105 lines)
- **Total deletion**: 2,208 lines (37% reduction in pkg/api)
- **Final verification**: 39/39 smoke tests passing, all spot checks successful
- **Zero compilation errors**: Clean build with no legacy type references
- **Architecture**: Single source of truth - all code uses generated types directly

**All commands now use direct genqlient types:**
- Read operations: `issue list`, `issue get`, `issue search`, `project list`, `project get`, `team list`, `team get`, `team members`, `user list`, `user get`, `user me`, `comment list`
- Write operations: `issue assign`, `issue create`, `issue update`, `comment create`
- Authentication: `auth login`, `auth status` (GetViewer for validation)

**Final architecture benefits:**
- **No adapter layer**: Commands call generated functions directly
- **No conversion overhead**: Zero translation between legacy and generated types
- **Full type safety**: Compile-time validation throughout entire codebase
- **Simplified codebase**: 37% reduction in pkg/api (3,654 lines deleted across all phases)
- **Performance**: Team workflow states embedded, 50% API call reduction for state updates
- **Maintainability**: Single source of truth, breaking API changes caught at compile time

The migration is complete. All operations use genqlient-generated types directly with full type safety, simplified architecture, and optimized performance.

### Configuration

- **Config file**: `~/.lincli.yaml` (optional)
- **Auth file**: `~/.lincli-auth.json` (required for authenticated commands)
- **Viper**: Used for config management
- **Environment**: `LINEAR_API_KEY` env var NOT used (only file-based auth)

## Adding New Commands

### Using Direct genqlient Types (Recommended for Read Operations)
For new read commands (list, get, search):

1. **Define GraphQL operation** in appropriate `pkg/api/operations/<entity>.graphql` file:
   ```graphql
   query ListMyData($filter: MyDataFilter, $first: Int, $after: String, $orderBy: PaginationOrderBy) {
       myData(filter: $filter, first: $first, after: $after, orderBy: $orderBy) {
           nodes {
               id
               name
               # ... fields you need
           }
           pageInfo { hasNextPage endCursor }
       }
   }
   ```

2. **Generate code**:
   ```bash
   go generate ./pkg/api
   ```
   This creates type-safe functions in `pkg/api/generated.go` (e.g., `ListMyData()`)

3. **Create typed filter builder** in command file (if filters needed):
   ```go
   func buildMyDataFilterTyped(cmd *cobra.Command) api.MyDataFilter {
       filter := api.MyDataFilter{}
       if name, _ := cmd.Flags().GetString("name"); name != "" {
           filter.Name = stringEq(name)  // Use helper functions
       }
       return filter
   }
   ```

4. **Implement command handler** in appropriate `cmd/*.go` file:
   ```go
   - Parse flags
   - Get auth header via `auth.GetAuthHeader()`
   - Create client: `client := api.NewClient(authHeader)`
   - Build typed filter: `filter := buildMyDataFilterTyped(cmd)`
   - Convert pagination params to pointers
   - Call generated function: `resp, err := api.ListMyData(ctx, client, filter, &limit, nil, orderByEnum)`
   - Access response: `resp.MyData.Nodes`
   - Render output using fragment fields (e.g., `node.MyDataListFields.Name`)
   ```

5. **Register command** in `init()` function

6. **Update README.md** with command documentation

7. **Add to smoke_test.sh** if read-only

**Key patterns:**
- Use typed filter structs (`api.MyDataFilter`) instead of `map[string]interface{}`
- Call generated functions directly (`api.ListMyData()`) - no adapters
- Access fields through fragments (`node.MyDataListFields`)
- Add nil checks for nullable fields
- Use helper functions for common patterns (stringEq, boolEq, etc.)

### Using Direct genqlient Types for Write Operations (Recommended)
For new write commands (create, update, delete):

1. **Define GraphQL mutation** in appropriate `pkg/api/operations/<entity>.graphql` file:
   ```graphql
   mutation CreateMyData($input: MyDataCreateInput!) {
       myDataCreate(input: $input) {
           myData {
               ...MyDataFields
           }
       }
   }
   ```

2. **Generate code**:
   ```bash
   go generate ./pkg/api
   ```

3. **Create input builder** (for complex commands with 5+ fields):
   ```go
   func buildMyDataCreateInput(cmd *cobra.Command) api.MyDataCreateInput {
       input := api.MyDataCreateInput{
           RequiredField: value,  // Non-pointer required fields
       }

       // Use Changed() for optional fields to distinguish "not set" from "set to empty"
       if cmd.Flags().Changed("optional-field") {
           val, _ := cmd.Flags().GetString("optional-field")
           input.OptionalField = &val
       }

       return input
   }
   ```

4. **Implement command handler**:
   ```go
   - Parse flags
   - Build typed input using builder function or inline (for simple cases)
   - Call generated mutation: `resp, err := api.CreateMyData(ctx, client, &input)`
   - Unwrap response: `data := resp.MyDataCreate.MyData`
   - Render output using fragment fields
   ```

5. **Test manually** with comprehensive test cases

**Key patterns for write operations:**
- Use `cmd.Flags().Changed()` to detect which optional fields were actually set
- Builder functions for 5+ fields, inline construction for 1-3 fields
- All optional input fields are pointers
- Pass inputs as pointers to mutation functions (`&input`)
- Response unwrapping: `resp.MutationName.Entity`

### Advanced Patterns: Multi-Step Operations

For operations requiring file uploads or multi-step API flows, see the **Attachment Commands Pattern** section below for comprehensive guidance on:
- File upload flow (validation → upload → attachment creation)
- Progress tracking with retry logic
- Multiple file support with coordinated flag parsing
- Best-effort error handling strategies

The attachment commands (`cmd/attachment.go`) serve as a reference implementation for complex operations.

### Updating Linear's GraphQL Schema
When Linear's API changes, update the schema:

```bash
# Download latest schema
curl -H "Authorization: Bearer $LINEAR_API_KEY" \
     -H "Content-Type: application/json" \
     -d '{"query": "{ __schema { types { name kind description fields { name } } } }"}' \
     https://api.linear.app/graphql | jq > pkg/api/schema.graphql

# Or use the update script if available
./scripts/update-schema.sh

# Regenerate code
go generate ./pkg/api

# Fix any compilation errors from breaking changes
```

## Attachment Commands Pattern

The attachment commands (`cmd/attachment.go`) demonstrate several advanced patterns for multi-step operations and file handling:

### Multi-Subcommand Structure
Attachment management uses a parent command with five subcommands:
- `attachment list` - Read operation with pagination
- `attachment create` - URL attachment creation (simple write)
- `attachment upload` - File upload to Linear storage (complex multi-step)
- `attachment update` - Update metadata or re-upload files
- `attachment delete` - Delete operation

**Key pattern**: All subcommands are registered under `attachmentCmd` in their respective `init()` functions.

### File Upload Flow

File uploads require a three-step process (Linear's API requirement):

1. **Validation Phase** (local, before any API calls)
   ```go
   - Check file exists and is readable
   - Validate size (50MB limit)
   - Detect content type (extension-based, fallback to content sniffing)
   - Collect all validation errors before failing
   ```

2. **Upload Phase** (GraphQL → HTTP → GraphQL)
   ```go
   // Step 1: Get pre-signed URL from Linear
   uploadResp, err := api.FileUpload(ctx, client, contentType, filename, size)

   // Step 2: HTTP PUT to pre-signed URL with progress tracking
   err = uploadFileWithProgress(path, uploadResp.FileUpload.UploadUrl, uploadResp.FileUpload.Headers, size, quiet)

   // Step 3: Create attachment record using asset URL
   input := api.AttachmentCreateInput{
       IssueId: issueID,
       Title:   title,
       Url:     uploadResp.FileUpload.AssetUrl,  // Use returned asset URL
   }
   attachResp, err := api.AttachmentCreate(ctx, client, &input)
   ```

3. **Retry Logic** (automatic, transparent to user)
   - Up to 3 retry attempts with exponential backoff (1s, 2s, 4s)
   - Only network errors and 5xx status codes trigger retries
   - 4xx status codes fail immediately (non-retryable)
   - Progress bar recreated on each retry attempt

### Multiple File Support

The `upload` command supports multiple files with individual metadata:

```bash
lincli attachment upload LIN-123 \
  --file report.pdf --title "Q4 Report" --subtitle "Draft" \
  --file screenshot.png --title "Bug Screenshot"
```

**Implementation pattern**:
- Use `StringArray` flags for repeatable values
- Parse flags into `[]fileAttachment` structs
- Validate all files before uploading any
- Continue with remaining files if one fails (best-effort)
- Report summary at end: "N succeeded, M failed"

### Flag Parsing for Related Values

Multiple files require coordinated flag parsing:

```go
func parseFileFlags(cmd *cobra.Command) ([]fileAttachment, error) {
    files, _ := cmd.Flags().GetStringArray("file")
    titles, _ := cmd.Flags().GetStringArray("title")
    subtitles, _ := cmd.Flags().GetStringArray("subtitle")

    // Validate counts match
    if len(files) != len(titles) {
        return nil, fmt.Errorf("each --file must have a corresponding --title")
    }

    // Build attachment structs with optional fields
    for i := range files {
        att := fileAttachment{path: files[i], title: titles[i]}
        if i < len(subtitles) && subtitles[i] != "" {
            att.subtitle = subtitles[i]
        }
        attachments = append(attachments, att)
    }
}
```

### File Validation Helpers

Reusable validation functions for file operations:

- `validateFile(path string) (int64, error)` - Check exists, readable, size <50MB
- `detectContentType(path string) (string, error)` - MIME type detection
- `formatSize(bytes int64) string` - Human-readable sizes (KB, MB, GB)

### Progress Tracking

File uploads show real-time progress using `progressbar/v3`:

```go
bar := progressbar.DefaultBytes(
    fileSize,
    fmt.Sprintf("Uploading %s (%s)...", filename, formatSize(fileSize)),
)
reader := progressbar.NewReader(file, bar)
req, err := http.NewRequest("PUT", uploadURL, &reader)
```

**JSON mode consideration**: Progress bars are suppressed when `--json` flag is set (quiet mode).

### Error Handling Strategy

Attachment commands use **best-effort** error handling:

1. **Validate everything first** - Collect all validation errors before failing
2. **Fail fast on validation** - Don't attempt uploads if any file is invalid
3. **Continue on upload failure** - Process remaining files if one fails
4. **Report comprehensive results** - Show which succeeded and which failed
5. **Exit code reflects outcome** - Exit 1 if any failures occurred

Example output:
```
Validating files...
✓ report.pdf (2.3 MB) - OK
✓ screenshot.png (145.7 KB) - OK

Uploading report.pdf (2.3 MB)...
✓ Attached report.pdf to LIN-123

Uploading screenshot.png (145.7 KB)...
✗ Network error, retrying... (attempt 1/3)
✓ Attached screenshot.png to LIN-123

Summary: 2 succeeded, 0 failed
```

### Common Attachment Operations

**List attachments** (simple read):
```bash
lincli attachment list LIN-123
lincli attachment list LIN-123 --json  # Machine-readable
lincli attachment list LIN-123 --sort updated --limit 20
```

**Create URL attachment** (external resource):
```bash
lincli attachment create LIN-123 \
  --url "https://github.com/org/repo/pull/456" \
  --title "Fix PR" \
  --subtitle "Merged" \
  --metadata "status=merged,author=user"
```

**Upload files** (to Linear storage):
```bash
# Single file
lincli attachment upload LIN-123 --file report.pdf --title "Q4 Report"

# Multiple files with metadata
lincli attachment upload LIN-123 \
  --file report.pdf --title "Q4 Report" --subtitle "Draft" \
  --file screenshot.png --title "Error Screenshot" \
  --file logs.txt --title "Debug Logs"
```

**Update attachment** (metadata or re-upload):
```bash
# Update metadata only
lincli attachment update <attachment-id> --title "Updated Title" --subtitle "Final"

# Re-upload file (file attachments only)
lincli attachment update <attachment-id> --file new-report.pdf

# Change URL (URL attachments only)
lincli attachment update <attachment-id> --url "https://new-url.com"
```

**Delete attachment**:
```bash
lincli attachment delete <attachment-id>
```

### Adding New Commands with File Upload

When adding commands that need file uploads:

1. **Add GraphQL operations** to `pkg/api/operations/attachments.graphql`:
   - `FileUpload` mutation (already exists for attachments)
   - Your entity-specific mutation that accepts asset URLs

2. **Generate code**: `go generate ./pkg/api`

3. **Implement validation helpers** (if not reusing attachment helpers):
   - File size limits
   - Content type detection
   - Path resolution and existence checks

4. **Implement upload helper** with retry logic:
   - Call `FileUpload` mutation
   - HTTP PUT with progress bar
   - Call your mutation with asset URL
   - Handle retries transparently

5. **Add command with proper error handling**:
   - Validate before uploading
   - Show progress for user operations
   - Support quiet mode for scripting
   - Provide clear error messages

6. **Test with various file types and sizes**:
   - Small files (<1MB)
   - Large files (close to limit)
   - Different content types
   - Network interruption scenarios

### Notes for AI Agents

When working with attachment commands programmatically:

- **Always use `--json` flag** for machine-readable output
- **Validate files locally first** before calling upload commands
- **Check returned JSON for `error` field** to detect failures
- **Parse validation_errors array** for detailed failure information
- **Respect 50MB file size limit** - check before attempting upload
- **Use absolute paths** for file arguments to avoid path resolution issues
- **Handle partial failures** - some files may succeed while others fail
- **Retry on network errors** - upload command has built-in retry logic
- **Don't retry 4xx errors** - these indicate invalid requests (e.g., file too large)

## Important Notes

### Issue Filtering
- **Default behavior**: List commands filter to last 6 months (`--newer-than 6_months_ago`)
- **Rationale**: Performance for large workspaces
- **Override**: Use `--newer-than all_time` to see all items
- **Completed items**: Excluded by default, use `--include-completed` flag

### Search vs List
- `issue list`: Uses filters, supports `--assignee`, `--state`, `--team`, `--priority`
- `issue search`: Uses Linear's full-text index, searches title/description/comments
- Both support `--newer-than` and `--include-completed` flags

### Sorting Options
All list commands support `--sort` flag:
- `linear` (default): Linear's manual sort order
- `created`: Sort by creation date (newest first)
- `updated`: Sort by update date (most recently updated first)

### Version Management
- Version is injected at build time via `-ldflags`
- Set in `Makefile` using git tags or commit hash
- Default value is `"dev"` for local development

### Release Process
This is a personal fork. For release process, simply:
1. Create and push git tag (e.g., `v1.2.3`)
2. Build from source using `make build && make install`

### Embedded README
- `main.go` embeds `README.md` using `//go:embed`
- Rendered by `lincli docs` command
- Uses `glamour` for terminal markdown rendering
- Ensures users always have access to docs offline

## Linear API Specifics

### Authentication
- Personal API Keys only (from https://linear.app/settings/api)
- Rate limit: 5,000 requests/hour
- API endpoint: `https://api.linear.app/graphql`

### Common Entities
- **Issue**: `identifier` (e.g., "LIN-123"), includes state, assignee, team, priority
- **Team**: `key` (e.g., "ENG"), not display name
- **Project**: Uses UUID, not human-readable identifier
- **User**: Identified by email for lookups, has `isMe` field for current user
- **State**: Workflow states (e.g., "Todo", "In Progress", "Done")
- **Priority**: 0=None, 1=Urgent, 2=High, 3=Normal, 4=Low

### Parent-Child Relationships
Issues support hierarchy:
- `parent`: Parent issue reference
- `children`: Array of sub-issues
- Displayed recursively in `issue get` command

## Testing Philosophy

- **Smoke tests**: Fast, read-only, safe with production credentials
- **No destructive tests**: All integration tests are read-only
- **Test API key**: Use `.env.test` for integration tests (optional)
- **Manual verification**: Critical operations (create, update) tested manually

## AI Agent Considerations

This tool is designed for both human and AI agent use:

- **Always use `--json` flag** for programmatic access
- **Respect rate limits**: Linear allows 5,000 req/hour
- **Use time filters**: Always specify `--newer-than` to avoid large data loads
- **Issue identifiers**: Use format "TEAM-NUMBER" (e.g., "ENG-123")
- **Team keys**: Use uppercase team key (e.g., "ENG"), not display name
- **Email for users**: Use email addresses for user lookups
- **Error handling**: JSON output includes `{"error": "message"}` format
